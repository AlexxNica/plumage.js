<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: view/form/fields/Field.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="../styles/docs.css">
</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="brand" href="../">PlumageJS</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li>
            <a href="../">Home</a>
          </li>
          <li class="active">
            <a href="index.html">API</a>
          </li>
          <li>
            <a href="../examples.html">Examples</a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>
<div class="container">
  <div class="row">
<div id="main" class="span8">
    <h1 class="page-title">Source: view/form/fields/Field.js</h1>
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>
define([
  'jquery',
  'underscore',
  'backbone',
  'handlebars',
  'PlumageRoot',
  'view/ModelView',
  'text!view/form/fields/templates/Field.html'
], function($, _, Backbone, Handlebars, Plumage, ModelView, template) {



  return Plumage.view.form.fields.Field = ModelView.extend(
  /** @lends Plumage.view.form.fields.Field.prototype */
  {

    template: template,

    /**
     * Template for html input element.
     * This template is separate so that it can be reused by subclasses.
     */
    fieldTemplate: '&lt;input type="text" name="{{valueAttr}}" {{#placeholder}}placeholder="{{.}}"{{/placeholder}} value="{{value}}" {{#readonly}}readonly="readonly"{{/readonly}}/>',

    /**
     * optional. model attribute to display as label
     */
    labelAttr: undefined,

    /**
     * Value to display as label if no labelAttr
     */
    label: undefined,

    /**
     * model attribute to display and edit
     */
    valueAttr: undefined,

    /**
     * input's name attribute
     */
    fieldName: undefined,

    /**
     * If updateModelOnChange is set, the model is updated on every change
     */
    updateModelOnChange: false,

    /**
     * The view value. It's seperate from the model value, and used for rerendering.
     *
     * Because it comes from the dom, value is always a string.
     */
    value: '',

    /** Text to show when blank */
    placeholder: undefined,

    /** required, minLength, maxLength, email, cc etc.*/
    validationRules: undefined,

    /** Template to show when validation fails */
    validationMessages: {
      required: 'required',
      minLength: 'Must be at least {{param0}} chars',
      maxLength: 'Must not be more than {{param0}} chars',
      email: 'Not a valid email address'
    },

    /** error, warning, success. Cleared on model load */
    validationState: undefined,

    /** message to display next to field, eg error message */
    message: undefined,


    /**
     * An editable view for displaying and editing a single value of a model.
     *
     * The value displayed (the view value) is allowed to differ from the model's value
     * until updateModel is called.
     *
     * To automatically update the model on change set updateModelOnChange = true.
     *
     * Notes:
     *  - In order to be used in a Form, Field subclasses must render an input element.
     *  - The rendered dom also has state. The view value *must* be kept in sync with the
     *    DOM value in case the field needs to be rerendered. By default this is done by setting
     *    the view value to the result of getValueFromDom when the DOM value changes.
     *     - Make sure to override getValueFromDom if your rendered DOM is not an input tag.
     *  - When triggering a change event, make sure both DOM and backbone events are triggered.
     *    Since a DOM event triggers a backbone event, do this by triggering a DOM event.
     *
     * @constructs
     * @extends Plumage.view.ModelView
     */
    initialize: function() {
      ModelView.prototype.initialize.apply(this, arguments);
      this.className = this.className ? this.className + ' field' : 'field';
    },

    onRender: function() {
      var inputEl = this.getInputEl();
      var hasFocus = inputEl ? inputEl.is(':focus') : false;
      Handlebars.registerPartial('field', this.fieldTemplate);
      ModelView.prototype.onRender.apply(this, arguments);

      inputEl = this.getInputEl();
      if (inputEl && hasFocus) {
        inputEl.focus();
      }
    },

    // This implementation avoids rerendering (and losing cursor position),
    // however, it has to be overridden frequently.
    // Maybe move this into a subclass TextField?
    update: function(isLoad) {
      if (this.isRendered) {
        var val = this.getInputEl().val(),
          newVal = this.getValueString(this.getValue());
        if (val !== newVal) {
          this.getInputEl().val(newVal);
        }
      } else {
        this.render();
      }
    },

    //
    // Init Events
    //

    delegateEvents: function(events) {
      events = events || _.result(this, 'events');
      var selector = this.getInputSelector();
      if (selector) {
        events = _.clone(events || {});
        events['blur ' +selector] = 'onBlur';
        events['focus ' +selector] = 'onFocus';
        events['submit ' +selector] = 'onSubmit';
        events['change ' +selector] = 'onChange';
        events['input ' +selector] = 'onInput'; //for text fields
        events['keydown ' +selector] = 'onKeyDown'; //detect enter/escape etc
        events['mouseup ' +selector] = 'onChange'; //for select/checkbox etc
      }
      Backbone.View.prototype.delegateEvents.apply(this, [events]);
    },

    undelegateEvents: function() {
      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
      var inputEl = this.getInputEl();
      if (inputEl) {
        inputEl.off('.field');
      }
    },

    getInputSelector: function() {
      return this.$el.is(':input') ? '' : ':input:first';
    },

    getInputEl: function() {
      var selector = this.getInputSelector();
      return selector ? this.$(selector).first() : this.$el;
    },

    hasValue: function() {
      var value = this.getValue();
      return value !== null && value !== undefined && value !== '';
    },

    //
    // Modifiers
    //

    focus: function() {
      this.getInputEl().focus();
    },

    //
    // Overrides
    //

    getTemplateData: function() {
      var data = {
        label: this.getLabel(),
        valueAttr: this.valueAttr,
        value: this.getValueString(this.getValue()),
        hasValue: this.hasValue(),
        placeholder: this.placeholder,
        readonly: this.readonly,
        validationState: this.validationState,
        message: this.message
      };
      return data;
    },

    setModel: function() {
      ModelView.prototype.setModel.apply(this, arguments);
      this.setValidationState(null, null);
      this.updateValueFromModel();
    },

    //
    // Attributes
    //

    getValue: function() {
      return this.value;
    },

    getValueString: function(value) {
      return value;
    },

    /**
     * updates the field value, and triggers change (both plumage and dom events)
     *
     * Note: This is not the only path to change the field value. The field value can also be changed by
     * updateValueFromModel, so do not update non-model view state here. Do that in valueChanged.
     */
    setValue: function(newValue, options) {
      options = options || {};
      if (this.getValue() === newValue) {
        return;
      }
      this.value = newValue;

      if (this.updateModelOnChange && this.model) {
        this.updateModel(this.rootModel);
      } else {
        this.update();
      }

      this.valueChanged();

      if (!options.silent) {
        this.changing = true;
        this.trigger('change', this, this.getValue());

        //for catching in form
        this.triggerChange();
        this.changing = false;
      }
    },

    getLabel: function() {
      if (this.labelAttr) {
        return this.model ? this.model.get(this.labelAttr) : null;
      }
      return this.label;
    },

    blur: function() {
      this.$el.blur();
    },

    //
    // Validation
    //

    validators: {
      required: function(value, params) {
        return value !== undefined && value !== '';
      },
      minLength: function(value, params) {
        return value.length >= params;
      },
      maxLength: function(value, params) {
        return value.length &lt;= params;
      },
      email: function(value) {
        return (/^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/).test(value);
      }
    },

    setValidationState: function(state, message) {
      this.validationState = state;
      this.message = message;
      this.$('.control-group').attr('class', 'control-group');
      if (this.validationState) {
        this.$('.control-group').addClass(this.validationState);
      }
      this.$('.help-inline').html(this.message);
    },

    validate: function() {
      var value = this.getValue();
      var rules = this.validationRules;

      if (rules) {
        if (!$.isPlainObject(rules)) {
          //eg 'required'
          var newRules = {};
          newRules[rules] = true;
          rules = newRules;
        }

        var success;
        //check required first
        if (rules.required) {
          success = this.applyValidator(value, rules.required, 'required');
        }
        if (success) {
          _.keys(rules).every(function(k) {
            if (k === 'required') {
              return true;
            }
            return success = this.applyValidator(value, rules[k], k);
          }.bind(this));
        }
        if (success) {
          this.setValidationState(null,null);
        }
        return success;
      }
      return true;
    },

    applyValidator: function(value, params, name) {
      params = $.isArray(params) ? params : [params];
      var validator = this.validators[name];
      if (!validator(value, params)) {
        var message = this.getValidationMessage(name, params);
        this.setValidationState('error', message);
        return false;
      }
      return true;
    },

    getValidationMessage: function(name, params) {
      var message = this.validationMessages[name] || 'invalid';
      return Handlebars.compile(message)(_.object(_.map(params, function(x, i) {return ['param' + i, x];})));
    },

    ////
    //
    // Helpers
    //
    ////


    //
    // View value &lt;--> Model
    //

    isValid: function() {
      return this.validate();
    },

    updateModel: function(rootModel, parentModel) {
      var model = this.getModelFromRoot(this.relationship, rootModel, parentModel),
        value = this.getValue();
      return model.set(this.valueAttr, value) !== false;
    },

    updateValueFromModel: function() {
      if (this.model) {
        this.value = this.getValueFromModel();
        this.valueChanged();

        if (this.isRendered) {
          this.update();
        }
      }
    },

    getValueFromModel: function() {
      if (this.model) {
        var result = this.model.get(this.valueAttr);
        return result === undefined ? '' : result;
      }
    },

    //
    // View value &lt;--> DOM value
    //

    getValueFromDom: function() {
      var inputEl = this.getInputEl();
      if (inputEl && inputEl.val) {
        return inputEl.val();
      }
    },

    processDomValue: function(value) {
      return value;
    },

    //
    // Gets current value from model
    //

    triggerChange: function(query) {
      //trigger change by blurring to prevent 2nd change event on blur
      var el = this.getInputEl();
      if (el.is(':focus')) {
        el.blur();
        el.focus();
      } else {
        el.change();
      }
    },

    isDomValueValid: function() {
      return true;
    },

    updateValueFromDom: function() {
      var newValue = this.getValueFromDom();

      if (this.isDomValueValid(newValue)) {
        newValue = this.processDomValue(newValue);
        if (!this.changing) {
          this.setValue(newValue, {silent: true});
        }
        this.trigger('change', this, this.getValue());
      } else {
        this.update();
      }
    },

    /** Hook called when value changes. Useful for keeping view state in sync */
    valueChanged: function() {
      return;
    },

    //
    // Event handlers
    //

    onChange: function(e) {
      this.updateValueFromDom();
    },

    onInput: function(e) {
      this.updateValueFromDom();
    },

    onKeyDown: function(e) {
      //do nothing
    },

    onBlur: function(e) {
      this.validate();
      this.trigger('blur', this);
    },

    onFocus: function(e){
      //do nothing
    },

    onSubmit: function(e) {
      this.trigger('submit', this);
    },

    onModelChange: function (e) {
      if (e.changed[this.valueAttr] !== undefined) {
        this.updateValueFromModel();
      }
    },

    onModelLoad: function () {
      this.setValidationState(null, null);
      this.updateValueFromModel();
    },

    onModelInvalid: function(model, validationError) {
      if (validationError) {
        var message = validationError[this.valueAttr];
        if (message) {
          if ($.isArray(message)) {
            message = message[0];
          }
          this.setValidationState('error', message);
        }
      }
    }
  });
});
</code></pre>
        </article>
    </section>




</div>

<nav class="span4">
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Plumage.App.html">App</a></li><li><a href="Plumage.collection.BufferedCollection.html">BufferedCollection</a></li><li><a href="Plumage.collection.Collection.html">Collection</a></li><li><a href="Plumage.collection.GridData.html">GridData</a></li><li><a href="Plumage.collection.Selection.html">Selection</a></li><li><a href="Plumage.controller.BaseController.html">BaseController</a></li><li><a href="Plumage.controller.ModelController.html">ModelController</a></li><li><a href="Plumage.ControllerManager.html">ControllerManager</a></li><li><a href="Plumage.History.html">History</a></li><li><a href="Plumage.model.Filter.html">Filter</a></li><li><a href="Plumage.model.Model.html">Model</a></li><li><a href="Plumage.RequestManager.html">RequestManager</a></li><li><a href="Plumage.Router.html">Router</a></li><li><a href="Plumage.util.Logger.html">Logger</a></li><li><a href="Plumage.view.CollectionView.html">CollectionView</a></li><li><a href="Plumage.view.ContainerView.html">ContainerView</a></li><li><a href="Plumage.view.form.fields.DateField.html">DateField</a></li><li><a href="Plumage.view.form.fields.DateRangeField.html">DateRangeField</a></li><li><a href="Plumage.view.form.fields.Field.html">Field</a></li><li><a href="Plumage.view.ModelView.html">ModelView</a></li><li><a href="Plumage.view.View.html">View</a></li></ul><h3>Namespaces</h3><ul><li><a href="Plumage.html">Plumage</a></li><li><a href="Plumage.collection.html">collection</a></li><li><a href="Plumage.controller.html">controller</a></li><li><a href="Plumage.model.html">model</a></li><li><a href="Plumage.util.html">util</a></li><li><a href="Plumage.vendor.html">vendor</a></li><li><a href="Plumage.view.html">view</a></li><li><a href="Plumage.view.comment.html">comment</a></li><li><a href="Plumage.view.controller.html">controller</a></li><li><a href="Plumage.view.form.html">form</a></li><li><a href="Plumage.view.form.fields.html">fields</a></li><li><a href="Plumage.view.form.fields.picker.html">picker</a></li><li><a href="Plumage.view.grid.html">grid</a></li><li><a href="Plumage.view.menu.html">menu</a></li></ul>
</nav>
</div>
</div>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
